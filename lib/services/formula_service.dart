import 'dart:io';
import 'package:tapster/models/tapster_config.dart';
import 'package:tapster/services/asset_service.dart';

class FormulaService {
  static const String defaultFormulaTemplate = '''
# Generated by tapster on {{TIMESTAMP}}
class {{CLASS_NAME}} < Formula
  desc "{{DESCRIPTION}}"
  homepage "{{HOMEPAGE}}"
  url "{{URL}}"
  sha256 "{{SHA256}}"
  license "{{LICENSE}}"

  {{#if depends_on_brew}}{{#each depends_on_brew}}depends_on "{{this}}"{{/each}}{{/if}}

  def install
    bin.install "{{EXECUTABLE_NAME}}"
  end

  test do
    system "#{bin}/{{EXECUTABLE_NAME}}", "--version"
  end
end
''';

  Future<String> generateFormula(TapsterConfig config) async {
    final assetService = AssetService();
    final now = DateTime.now().toUtc();
    final timestamp = now.toIso8601String();

    final Map<String, dynamic> context = {
      'CLASS_NAME': _toClassName(config.name),
      'DESCRIPTION': config.description,
      'HOMEPAGE': config.homepage,
      'LICENSE': config.license,
      'TIMESTAMP': timestamp,
    };

    // Handle asset
    if (config.asset.isNotEmpty) {
      final assetInfo = await assetService.getAssetInfo(config.asset);
      context['URL'] = _getDefaultUrl(config, config.version);
      context['SHA256'] = config.checksum ?? assetInfo.checksum;
      context['EXECUTABLE_NAME'] = _getExecutableName(config.asset);
    }

    // Handle dependencies
    if (config.dependencies.isNotEmpty) {
      context['depends_on_brew'] = config.dependencies;
    }

    return _renderTemplate(defaultFormulaTemplate, context);
  }

  String _renderTemplate(String template, Map<String, dynamic> context) {
    var result = template;

    // Replace simple variables
    context.forEach((key, value) {
      final placeholder = '{{$key}}';
      result = result.replaceAll(placeholder, value.toString());
    });

    // Handle conditional blocks
    result = _processConditionBlocks(result, context);

    return result;
  }

  String _processConditionBlocks(
    String template,
    Map<String, dynamic> context,
  ) {
    // Handle each loops
    final eachRegex = RegExp(
      r'\{\{#each (\w+)\}\}(.*?)\{\{/each\}\}',
      dotAll: true,
    );
    template = template.replaceAllMapped(eachRegex, (match) {
      final arrayName = match.group(1)!;
      final content = match.group(2)!;
      final array = context[arrayName];

      if (array is List) {
        return array
            .map((item) => content.replaceAll('{{this}}', item.toString()))
            .join('');
      }
      return '';
    });

    // Handle if/else blocks
    final ifElseRegex = RegExp(
      r'\{\{#if (\w+)\}\}(.*?)\{\{else\}\}(.*?)\{\{/if\}\}',
      dotAll: true,
    );
    template = template.replaceAllMapped(ifElseRegex, (match) {
      final condition = match.group(1)!;
      final ifContent = match.group(2)!;
      final elseContent = match.group(3)!;
      final value = context[condition];
      final hasCondition =
          value == true ||
          (value is List && value.isNotEmpty) ||
          value?.toString().isNotEmpty == true;

      return hasCondition ? ifContent : elseContent;
    });

    // Handle simple if blocks
    final ifRegex = RegExp(r'\{\{#if (\w+)\}\}(.*?)\{\{/if\}\}', dotAll: true);
    template = template.replaceAllMapped(ifRegex, (match) {
      final condition = match.group(1)!;
      final content = match.group(2)!;
      final value = context[condition];
      final hasCondition =
          value == true ||
          (value is List && value.isNotEmpty) ||
          value?.toString().isNotEmpty == true;

      return hasCondition ? content : '';
    });

    return template;
  }

  String _toClassName(String packageName) {
    // Convert package name to Ruby class name format
    final parts = packageName.split(RegExp(r'[-_\s]+'));
    return parts
        .map(
          (part) => part.isNotEmpty
              ? '${part[0].toUpperCase()}${part.substring(1)}'
              : '',
        )
        .join('');
  }

  String _getExecutableName(String path) {
    return _getFileName(path);
  }

  String _getFileName(String path) {
    return path.split(Platform.pathSeparator).last;
  }

  String _getDefaultUrl(TapsterConfig config, String version) {
    // Generate GitHub release URL
    final repo = config.repository.replaceAll('.git', '');
    return '$repo/releases/download/v$version/${config.name}';
  }
}
